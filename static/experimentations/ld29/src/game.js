// Generated by CoffeeScript 1.7.1
(function() {
  var Assets, Game, Keyboard, Mouse, clone, create_silhouette,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  CanvasRenderingContext2D.prototype.draw_image_index = function(img, width, height, index, x, y, draw) {
    var basex, basey, nbtiles;
    if (draw == null) {
      draw = true;
    }
    nbtiles = Math.ceil(img.width / width);
    basex = index % nbtiles;
    basex = basex * width;
    basey = Math.floor(index / nbtiles);
    basey = basey * height;
    if (draw) {
      return this.drawImage(img, basex, basey, width, height, x, y, width, height);
    } else {
      return {
        nbtiles: nbtiles,
        basex: basex,
        basey: basey
      };
    }
  };

  CanvasRenderingContext2D.prototype.get2darray_image = function(img) {
    var a, b, g, i, list_pixels, map, r, x, y, _i, _ref;
    this.save();
    this.drawImage(img, 0, 0);
    list_pixels = this.getImageData(0, 0, img.width, img.height).data;
    map = [];
    for (i = _i = 0, _ref = list_pixels.length; _i < _ref; i = _i += 4) {
      r = list_pixels[i + 0];
      g = list_pixels[i + 1];
      b = list_pixels[i + 2];
      a = list_pixels[i + 3];
      x = Math.floor((i / 4) % img.width);
      y = Math.floor(((i - x) / 4) / img.width);
      if (map[x]) {
        map[x][y] = [r, g, b, a];
      } else {
        map[x] = [[r, g, b, a]];
      }
    }
    this.restore();
    return map;
  };

  CanvasRenderingContext2D.prototype.fill_wrap_text = function(text, x, y, maxWidth, lineHeight) {
    var line, metrics, n, testLine, testWidth, words, _i, _ref;
    words = text.split(' ');
    line = '';
    for (n = _i = 0, _ref = words.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
      testLine = line + words[n] + ' ';
      metrics = this.measureText(testLine);
      testWidth = metrics.width;
      if (testWidth > maxWidth) {
        this.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    return this.fillText(line, x, y);
  };

  CanvasRenderingContext2D.prototype.tile_from_position = function(img, width, height, x, y) {
    var tile_by_line;
    tile_by_line = Math.ceil(img.width / (width + 1));
    x = Math.floor(x / (width + 1));
    y = Math.floor(y / (height + 1));
    return x + (y * tile_by_line);
  };

  Math.clamp = function(min, val, max) {
    return Math.max(min, Math.min(max, val));
  };

  Math.sign = function(x) {
    var _ref, _ref1;
    return (_ref = x === 0) != null ? _ref : {
      0: (_ref1 = x > 0) != null ? _ref1 : {
        1: -1
      }
    };
  };

  Math.between = function(min, val, max) {
    return val >= min && val <= max;
  };

  Math.rand = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  window.rgb = function(r, g, b, a) {
    if (a == null) {
      a = 1;
    }
    if (a === 1) {
      return "rgb(" + r + ", " + g + ", " + b + ")";
    } else {
      return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
    }
  };

  window.hsl = function(h, s, l, a) {
    if (a == null) {
      a = 1;
    }
    if (a === 1) {
      return "hsl(" + h + ", " + s + "%, " + l + "%)";
    } else {
      return "hsla(" + h + ", " + s + "%, " + l + "%, " + a + ")";
    }
  };

  window.preload_images = function(images, callback) {
    var i, image_loaded, nb_images_loaded, nb_images_to_load, new_image_loaded, preload;
    nb_images_loaded = 0;
    nb_images_to_load = Object.keys(images).length;
    image_loaded = [];
    new_image_loaded = function() {
      nb_images_loaded++;
    };
    for (i in images) {
      image_loaded[i] = new Image();
      image_loaded[i].onload = new_image_loaded;
      image_loaded[i].src = images[i];
    }
    preload = function() {
      if (nb_images_loaded === nb_images_to_load) {
        callback();
      } else {
        setTimeout(preload, 100);
      }
    };
    preload();
    return image_loaded;
  };

  clone = function(obj) {
    var k, new_obj, v;
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      if (v instanceof Object) {
        new_obj[k] = clone(v);
      } else {
        new_obj[k] = v;
      }
    }
    return new_obj;
  };

  create_silhouette = function(img, r, g, b, a) {
    var can, ctx, data, fdata, final_data, getIndex, getPosition, hasAdjacentPixel, height, i, isBlankPixel, width, _i, _ref;
    if (r == null) {
      r = 200;
    }
    if (g == null) {
      g = 200;
    }
    if (b == null) {
      b = 0;
    }
    if (a == null) {
      a = 200;
    }
    can = document.createElement('canvas');
    ctx = can.getContext('2d');
    width = img.width;
    height = img.height;
    final_data = null;
    data = null;
    can.width = width;
    can.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    data = ctx.getImageData(0, 0, width, height).data;
    final_data = ctx.getImageData(0, 0, width, height);
    fdata = final_data.data;
    getIndex = function(x, y) {
      return ((width * (y - 1)) + x - 1) * 4;
    };
    getPosition = function(i) {
      var x, y;
      x = null;
      y = null;
      i = (i / 4) + 1;
      x = i % width;
      y = ((i - x) / width) + 1;
      return {
        x: x,
        y: y
      };
    };
    hasAdjacentPixel = function(i) {
      var pos;
      pos = getPosition(i);
      if (pos.x < width && !isBlankPixel(getIndex(pos.x + 1, pos.y))) {
        return true;
      }
      if (pos.x > 1 && !isBlankPixel(getIndex(pos.x - 1, pos.y))) {
        return true;
      }
      if (pos.y < height && !isBlankPixel(getIndex(pos.x, pos.y + 1))) {
        return true;
      }
      if (pos.y > 1 && !isBlankPixel(getIndex(pos.x, pos.y - 1))) {
        return true;
      }
      return false;
    };
    isBlankPixel = function(i) {
      if (i < 0 || i >= data.length) {
        return true;
      }
      return data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0 && data[i + 3] === 0;
    };
    for (i = _i = 0, _ref = data.length; _i <= _ref; i = _i += 4) {
      if (isBlankPixel(i) && hasAdjacentPixel(i)) {
        fdata[i] = r;
        fdata[i + 1] = g;
        fdata[i + 2] = b;
        fdata[i + 3] = a;
      }
    }
    final_data.data = fdata;
    ctx.putImageData(final_data, 0, 0);
    return can;
  };

  Mouse = (function() {
    function Mouse(el, scale) {
      if (scale == null) {
        scale = 1;
      }
      this.on_mouse_wheel = __bind(this.on_mouse_wheel, this);
      this.on_mouse_move = __bind(this.on_mouse_move, this);
      this.on_mouse_down = __bind(this.on_mouse_down, this);
      this.on_mouse_up = __bind(this.on_mouse_up, this);
      this.x = 0;
      this.y = 0;
      this.click = null;
      this.mtime = 0;
      this.el = el;
      this.loose = null;
      this.iwheel = 0;
      this.scale = scale;
      document.addEventListener('mousedown', this.on_mouse_down, false);
      document.addEventListener('mousemove', this.on_mouse_move, false);
      document.addEventListener('mouseup', this.on_mouse_up, false);
      document.addEventListener('mousewheel', this.on_mouse_wheel, false);
      document.addEventListener('DOMMouseScroll', this.on_mouse_wheel, false);
    }

    Mouse.prototype.update = function() {
      this.mtime++;
      return this.iwheel = 0;
    };

    Mouse.prototype.on_mouse_up = function(e) {
      this.loose = this.mtime;
      return this.click = null;
    };

    Mouse.prototype.on_mouse_down = function(e) {
      this.on_mouse_move(e);
      return this.click = this.mtime;
    };

    Mouse.prototype.on_mouse_move = function(e) {
      this.x = Math.floor((e.pageX - (this.el != null ? this.el.offsetLeft : 0)) / this.scale);
      return this.y = Math.floor((e.pageY - (this.el != null ? this.el.offsetTop : 0)) / this.scale);
    };

    Mouse.prototype.on_mouse_wheel = function(e) {
      return this.iwheel = -Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
    };

    Mouse.prototype.up = function() {
      return this.click === null;
    };

    Mouse.prototype.down = function() {
      return this.click !== null;
    };

    Mouse.prototype.press = function() {
      return this.click === this.mtime;
    };

    Mouse.prototype.release = function() {
      return this.loose === this.mtime;
    };

    Mouse.prototype.wheel = function() {
      return this.iwheel === 1 || this.iwheel === 1;
    };

    return Mouse;

  })();

  window.Key = {
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    NUM0: 48,
    NUM1: 49,
    NUM2: 50,
    NUM3: 51,
    NUM4: 52,
    NUM5: 53,
    NUM6: 54,
    NUM7: 55,
    NUM8: 56,
    NUM9: 57,
    NUMPAD0: 96,
    NUMPAD1: 97,
    NUMPAD2: 98,
    NUMPAD3: 99,
    NUMPAD4: 100,
    NUMPAD5: 101,
    NUMPAD6: 102,
    NUMPAD7: 103,
    NUMPAD8: 104,
    NUMPAD9: 105,
    ADD: 107,
    SUB: 109,
    MUL: 106,
    DIV: 111,
    CAPSLOCK: 20,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    ISERT: 45,
    DELETE: 46,
    NUMLOCK: 144
  };

  Keyboard = (function() {
    function Keyboard() {
      this.onkeydown = __bind(this.onkeydown, this);
      this.onkeyup = __bind(this.onkeyup, this);
      this.keys = [];
      this.last = 0;
      this.ktime = 0;
      document.addEventListener('keydown', this.onkeydown, false);
      document.addEventListener('keyup', this.onkeyup, false);
    }

    Keyboard.prototype.update = function() {
      return this.ktime++;
    };

    Keyboard.prototype.onkeyup = function(e) {
      return this.keys[e.keyCode] = null;
    };

    Keyboard.prototype.onkeydown = function(e) {
      return this.keys[e.keyCode] = this.ktime;
    };

    Keyboard.prototype.up = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] == null;
    };

    Keyboard.prototype.down = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] != null;
    };

    Keyboard.prototype.press = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] === this.ktime;
    };

    Keyboard.prototype.str_to_code = function(k) {
      if (Key[k]) {
        return Key[k];
      } else {
        return null;
      }
    };

    return Keyboard;

  })();

  Assets = (function() {
    function Assets() {}

    Assets.img = null;

    Assets.init_images = function(assets, callback) {
      return Assets.img = preload_images(assets, callback);
    };

    Assets.get = function(str) {
      return Assets.img[str];
    };

    return Assets;

  })();

  Game = (function() {
    function Game() {
      this.update = __bind(this.update, this);
      this.create = __bind(this.create, this);
      this.can = document.getElementById('game');
      this.ctx = this.can.getContext('2d');
      this.width = 500;
      this.height = 500;
      this.can.width = this.width;
      this.can.height = this.height;
      this.mouse = new Mouse(this.can);
      this.kb = new Keyboard();
      this.angle = 0;
      this.size = 30;
      this.dir = -0.5;
      this.speed = 0;
      this.player = {
        x: this.width / 2 - 16 / 2,
        y: 100,
        width: 16,
        height: 16,
        speed: 0,
        acceleration: 0.2,
        max_speed: 2
      };
      Assets.init_images({
        player: 'gfx/player.png'
      }, this.create);
    }

    Game.prototype.create = function() {
      return this.update();
    };

    Game.prototype.update = function() {
      this.angle += 1.5;
      if (this.size < 10) {
        this.dir = 0.5;
        this.size = 11;
      } else if (this.size > 50) {
        this.dir = -0.5;
        this.size = 49;
      }
      this.speed += 0.1 * this.dir;
      this.size += this.speed;
      if (this.mouse.press()) {
        this.player.speed = -2.8;
      }
      this.player.speed += this.player.acceleration;
      this.player.y += this.player.speed;
      this.mouse.update();
      this.kb.update();
      this.draw();
      return requestAnimationFrame(this.update);
    };

    Game.prototype.draw = function() {
      var diff, i, _i;
      this.ctx.fillStyle = rgb(100, 220, 220);
      this.ctx.fillRect(0, 0, this.width, this.height);
      this.ctx.strokeStyle = rgb(255, 255, 255);
      this.ctx.lineWidth = 75;
      this.ctx.beginPath();
      this.ctx.arc(this.width / 2, this.height / 2, 190, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.fillStyle = rgb(255, 255, 255);
      this.ctx.beginPath();
      this.ctx.arc(this.width / 2, this.height / 2, 60, 0, Math.PI * 2);
      this.ctx.fill();
      for (i = _i = 0; _i < 4; i = ++_i) {
        this.ctx.save();
        this.ctx.translate(this.width / 2 - Math.sin(i * Math.PI / 2 - this.angle / 180) * 56, this.height / 2 - Math.cos(i * Math.PI / 2 - this.angle / 180) * 56);
        diff = (function() {
          switch (i) {
            case 0:
              return 180;
            case 1:
              return 90;
            case 2:
              return 0;
            case 3:
              return 270;
          }
        })();
        this.ctx.rotate((this.angle / 180) + diff * Math.PI / 180);
        this.ctx.fillStyle = rgb(255, 255, 255);
        this.ctx.fillRect(-25 / 2, 0, 25, this.size);
        this.ctx.fillRect(-25 / 2, this.size + 40, 25, 60 - this.size);
        this.ctx.restore();
      }
      this.ctx.drawImage(Assets.get('player'), this.player.x, this.player.y);
    };

    return Game;

  })();

  new Game();

}).call(this);
