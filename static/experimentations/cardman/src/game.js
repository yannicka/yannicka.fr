// Generated by CoffeeScript 1.7.1
(function() {
  var Assets, Card, Game, Keyboard, Monster, Mouse, Player, clone, create_silhouette,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  CanvasRenderingContext2D.prototype.draw_image_index = function(img, width, height, index, x, y, draw) {
    var basex, basey, nbtiles;
    if (draw == null) {
      draw = true;
    }
    nbtiles = Math.ceil(img.width / width);
    basex = index % nbtiles;
    basex = basex * width;
    basey = Math.floor(index / nbtiles);
    basey = basey * height;
    if (draw) {
      return this.drawImage(img, basex, basey, width, height, x, y, width, height);
    } else {
      return {
        nbtiles: nbtiles,
        basex: basex,
        basey: basey
      };
    }
  };

  CanvasRenderingContext2D.prototype.get2darray_image = function(img) {
    var a, b, g, i, list_pixels, map, r, x, y, _i, _ref;
    this.save();
    this.drawImage(img, 0, 0);
    list_pixels = this.getImageData(0, 0, img.width, img.height).data;
    map = [];
    for (i = _i = 0, _ref = list_pixels.length; _i < _ref; i = _i += 4) {
      r = list_pixels[i + 0];
      g = list_pixels[i + 1];
      b = list_pixels[i + 2];
      a = list_pixels[i + 3];
      x = Math.floor((i / 4) % img.width);
      y = Math.floor(((i - x) / 4) / img.width);
      if (map[x]) {
        map[x][y] = [r, g, b, a];
      } else {
        map[x] = [[r, g, b, a]];
      }
    }
    this.restore();
    return map;
  };

  CanvasRenderingContext2D.prototype.fill_wrap_text = function(text, x, y, maxWidth, lineHeight) {
    var line, metrics, n, testLine, testWidth, words, _i, _ref;
    words = text.split(' ');
    line = '';
    for (n = _i = 0, _ref = words.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
      testLine = line + words[n] + ' ';
      metrics = this.measureText(testLine);
      testWidth = metrics.width;
      if (testWidth > maxWidth) {
        this.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    return this.fillText(line, x, y);
  };

  CanvasRenderingContext2D.prototype.tile_from_position = function(img, width, height, x, y) {
    var tile_by_line;
    tile_by_line = Math.ceil(img.width / (width + 1));
    x = Math.floor(x / (width + 1));
    y = Math.floor(y / (height + 1));
    return x + (y * tile_by_line);
  };

  Math.clamp = function(min, val, max) {
    return Math.max(min, Math.min(max, val));
  };

  Math.sign = function(x) {
    var _ref, _ref1;
    return (_ref = x === 0) != null ? _ref : {
      0: (_ref1 = x > 0) != null ? _ref1 : {
        1: -1
      }
    };
  };

  Math.between = function(min, val, max) {
    return val >= min && val <= max;
  };

  Math.rand = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  window.rgb = function(r, g, b, a) {
    if (a == null) {
      a = 1;
    }
    if (a === 1) {
      return 'rgb(' + r + ', ' + g + ', ' + b + ')';
    } else {
      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
    }
  };

  window.preload_images = function(images, callback) {
    var i, image_loaded, nb_images_loaded, nb_images_to_load, new_image_loaded, preload;
    nb_images_loaded = 0;
    nb_images_to_load = Object.keys(images).length;
    image_loaded = [];
    new_image_loaded = function() {
      nb_images_loaded++;
    };
    for (i in images) {
      image_loaded[i] = new Image();
      image_loaded[i].onload = new_image_loaded;
      image_loaded[i].src = images[i];
    }
    preload = function() {
      if (nb_images_loaded === nb_images_to_load) {
        callback();
      } else {
        setTimeout(preload, 100);
      }
    };
    preload();
    return image_loaded;
  };

  clone = function(obj) {
    var k, new_obj, v;
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      if (v instanceof Object) {
        new_obj[k] = clone(v);
      } else {
        new_obj[k] = v;
      }
    }
    return new_obj;
  };

  create_silhouette = function(img, r, g, b, a) {
    var can, ctx, data, fdata, final_data, getIndex, getPosition, hasAdjacentPixel, height, i, isBlankPixel, width, _i, _ref;
    if (r == null) {
      r = 200;
    }
    if (g == null) {
      g = 200;
    }
    if (b == null) {
      b = 0;
    }
    if (a == null) {
      a = 200;
    }
    can = document.createElement('canvas');
    ctx = can.getContext('2d');
    width = img.width;
    height = img.height;
    final_data = null;
    data = null;
    can.width = width;
    can.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    data = ctx.getImageData(0, 0, width, height).data;
    final_data = ctx.getImageData(0, 0, width, height);
    fdata = final_data.data;
    getIndex = function(x, y) {
      return ((width * (y - 1)) + x - 1) * 4;
    };
    getPosition = function(i) {
      var x, y;
      x = null;
      y = null;
      i = (i / 4) + 1;
      x = i % width;
      y = ((i - x) / width) + 1;
      return {
        x: x,
        y: y
      };
    };
    hasAdjacentPixel = function(i) {
      var pos;
      pos = getPosition(i);
      if (pos.x < width && !isBlankPixel(getIndex(pos.x + 1, pos.y))) {
        return true;
      }
      if (pos.x > 1 && !isBlankPixel(getIndex(pos.x - 1, pos.y))) {
        return true;
      }
      if (pos.y < height && !isBlankPixel(getIndex(pos.x, pos.y + 1))) {
        return true;
      }
      if (pos.y > 1 && !isBlankPixel(getIndex(pos.x, pos.y - 1))) {
        return true;
      }
      return false;
    };
    isBlankPixel = function(i) {
      if (i < 0 || i >= data.length) {
        return true;
      }
      return data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0 && data[i + 3] === 0;
    };
    for (i = _i = 0, _ref = data.length; _i <= _ref; i = _i += 4) {
      if (isBlankPixel(i) && hasAdjacentPixel(i)) {
        fdata[i] = r;
        fdata[i + 1] = g;
        fdata[i + 2] = b;
        fdata[i + 3] = a;
      }
    }
    final_data.data = fdata;
    ctx.putImageData(final_data, 0, 0);
    return can;
  };

  Mouse = (function() {
    function Mouse(el, scale) {
      if (scale == null) {
        scale = 1;
      }
      this.on_mouse_wheel = __bind(this.on_mouse_wheel, this);
      this.on_mouse_move = __bind(this.on_mouse_move, this);
      this.on_mouse_down = __bind(this.on_mouse_down, this);
      this.on_mouse_up = __bind(this.on_mouse_up, this);
      this.x = 0;
      this.y = 0;
      this.click = null;
      this.mtime = 0;
      this.el = el;
      this.loose = null;
      this.iwheel = 0;
      this.scale = scale;
      document.addEventListener('mousedown', this.on_mouse_down, false);
      document.addEventListener('mousemove', this.on_mouse_move, false);
      document.addEventListener('mouseup', this.on_mouse_up, false);
      document.addEventListener('mousewheel', this.on_mouse_wheel, false);
      document.addEventListener('DOMMouseScroll', this.on_mouse_wheel, false);
    }

    Mouse.prototype.update = function() {
      this.mtime++;
      return this.iwheel = 0;
    };

    Mouse.prototype.on_mouse_up = function(e) {
      this.loose = this.mtime;
      return this.click = null;
    };

    Mouse.prototype.on_mouse_down = function(e) {
      this.on_mouse_move(e);
      return this.click = this.mtime;
    };

    Mouse.prototype.on_mouse_move = function(e) {
      this.x = Math.floor((e.pageX - (this.el != null ? this.el.offsetLeft : 0)) / this.scale);
      return this.y = Math.floor((e.pageY - (this.el != null ? this.el.offsetTop : 0)) / this.scale);
    };

    Mouse.prototype.on_mouse_wheel = function(e) {
      return this.iwheel = -Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
    };

    Mouse.prototype.up = function() {
      return this.click === null;
    };

    Mouse.prototype.down = function() {
      return this.click !== null;
    };

    Mouse.prototype.press = function() {
      return this.click === this.mtime;
    };

    Mouse.prototype.release = function() {
      return this.loose === this.mtime;
    };

    Mouse.prototype.wheel = function() {
      return this.iwheel === 1 || this.iwheel === 1;
    };

    return Mouse;

  })();

  window.Key = {
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    NUM0: 48,
    NUM1: 49,
    NUM2: 50,
    NUM3: 51,
    NUM4: 52,
    NUM5: 53,
    NUM6: 54,
    NUM7: 55,
    NUM8: 56,
    NUM9: 57,
    NUMPAD0: 96,
    NUMPAD1: 97,
    NUMPAD2: 98,
    NUMPAD3: 99,
    NUMPAD4: 100,
    NUMPAD5: 101,
    NUMPAD6: 102,
    NUMPAD7: 103,
    NUMPAD8: 104,
    NUMPAD9: 105,
    ADD: 107,
    SUB: 109,
    MUL: 106,
    DIV: 111,
    CAPSLOCK: 20,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    ISERT: 45,
    DELETE: 46,
    NUMLOCK: 144
  };

  Keyboard = (function() {
    function Keyboard() {
      this.onkeydown = __bind(this.onkeydown, this);
      this.onkeyup = __bind(this.onkeyup, this);
      this.keys = [];
      this.last = 0;
      this.ktime = 0;
      document.addEventListener('keydown', this.onkeydown, false);
      document.addEventListener('keyup', this.onkeyup, false);
    }

    Keyboard.prototype.update = function() {
      return this.ktime++;
    };

    Keyboard.prototype.onkeyup = function(e) {
      return this.keys[e.keyCode] = null;
    };

    Keyboard.prototype.onkeydown = function(e) {
      return this.keys[e.keyCode] = this.ktime;
    };

    Keyboard.prototype.up = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] == null;
    };

    Keyboard.prototype.down = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] != null;
    };

    Keyboard.prototype.press = function(k) {
      return this.keys[this.str_to_code(k.toUpperCase())] === this.ktime;
    };

    Keyboard.prototype.str_to_code = function(k) {
      if (Key[k]) {
        return Key[k];
      } else {
        return null;
      }
    };

    return Keyboard;

  })();

  Assets = (function() {
    function Assets() {}

    Assets.img = null;

    Assets.init_images = function(assets, callback) {
      return Assets.img = preload_images(assets, callback);
    };

    Assets.get = function(str) {
      return Assets.img[str];
    };

    return Assets;

  })();

  Monster = (function() {
    function Monster(_arg) {
      var attack, defense, description, height, img, name, width;
      name = _arg.name, description = _arg.description, attack = _arg.attack, defense = _arg.defense, width = _arg.width, height = _arg.height, img = _arg.img;
      this.name = name;
      this.description = description;
      this.attack = attack;
      this.defense = defense;
      this.width = width;
      this.height = height;
      this.img = img;
      this.img_hover = create_silhouette(this.img, 0, 0, 0, 255);
    }

    return Monster;

  })();

  Card = (function() {
    function Card(_arg) {
      var enemy, monster, position, visible, x, y;
      x = _arg.x, y = _arg.y, monster = _arg.monster, position = _arg.position, visible = _arg.visible, enemy = _arg.enemy;
      if (position == null) {
        position = 'visible';
      }
      if (visible == null) {
        visible = true;
      }
      if (enemy == null) {
        enemy = false;
      }
      this.x = x;
      this.y = y;
      this.monster = monster;
      this.hover = false;
      this.position = position;
      this.visible = visible;
      this.enemy = enemy;
    }

    Card.prototype.draw = function(ctx) {
      var dh, dw, dx, dy, img, sh, sw, sx, sy;
      img = this.monster.img;
      sx = 0;
      sy = this.monster.height;
      sw = this.monster.width;
      sh = this.monster.height;
      dx = this.x;
      dy = this.y;
      dw = sw;
      dh = sh;
      if (this.hover) {
        img = this.monster.img_hover;
        sy = this.monster.height;
      }
      if (this.enemy) {
        sy = 0;
        if (!this.visible) {
          img = Assets.get('monster_who');
        }
      }
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
      if (!this.enemy || this.visible) {
        ctx.fillStyle = rgb(255, 255, 255);
        ctx.font = 'normal 6px Cardfont';
        ctx.shadowColor = rgb(0, 0, 0);
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.textAlign = 'center';
        ctx.fillStyle = rgb(255, 255, 255);
        ctx.shadowColor = rgb(0, 0, 0);
        if (this.position === 'attack') {
          ctx.fillStyle = rgb(200, 0, 0);
          ctx.shadowColor = rgb(255, 0, 0);
        }
        ctx.fillText(this.monster.attack, this.x + this.monster.width / 2, this.y + this.monster.height + 10);
        ctx.fillStyle = rgb(255, 255, 255);
        ctx.shadowColor = rgb(0, 0, 0);
        if (this.position === 'defense') {
          ctx.fillStyle = rgb(0, 130, 0);
          ctx.shadowColor = rgb(0, 255, 0);
        }
        ctx.fillText(this.monster.defense, this.x + this.monster.width / 2, this.y + this.monster.height + 20);
        ctx.shadowBlur = 0;
      }
      if (this.position === 'defense') {
        return ctx.drawImage(Assets.get('shield'), this.x + 9, this.y + 9);
      } else if (this.position === 'attack') {
        return ctx.drawImage(Assets.get('sword'), this.x + 9, this.y + 9);
      }
    };

    Card.prototype.update_hover = function(mouse) {
      if (!this.visible && this.enemy) {
        return;
      }
      this.hover = false;
      if (mouse.x > this.x && mouse.x <= this.x + this.monster.width && mouse.y > this.y && mouse.y <= this.y + this.monster.height) {
        this.hover = true;
        document.body.style.cursor = 'pointer';
      }
      return this.monster.description;
    };

    return Card;

  })();

  Player = (function() {
    function Player() {
      this.cards_hands = [];
      this.cards_ground = [];
      this.cards_trash_bin = [];
      this.life = 0;
    }

    Player.prototype.add_card = function(card) {
      if (this.cards_ground.length < 8) {
        this.cards_hands.push(card);
        return this.cards_ground.push(this.cards_hands[this.cards_hands.length - 1]);
      }
    };

    return Player;

  })();

  Game = (function() {
    function Game() {
      this.update = __bind(this.update, this);
      this.create = __bind(this.create, this);
      this.can = document.getElementById('game');
      this.ctx = this.can.getContext('2d');
      this.width = 400;
      this.height = 300;
      this.scale = 2;
      this.can.width = this.width * this.scale;
      this.can.height = this.height * this.scale;
      if (this.ctx.mozImageSmoothingEnabled) {
        this.ctx.mozImageSmoothingEnabled = false;
      } else if (this.ctx.webkitImageSmoothingEnabled) {
        this.ctx.webkitImageSmoothingEnabled = false;
      } else if (this.ctx.oImageSmoothingEnabled) {
        this.ctx.oImageSmoothingEnabled = false;
      }
      if (this.ctx.imageSmoothingEnabled) {
        ctx.imageSmoothingEnabled = false;
      }
      this.ctx.scale(this.scale, this.scale);
      this.img = {};
      this.pp = null;
      this.mouse = new Mouse(this.can, this.scale);
      Assets.init_images({
        ground: 'gfx/ground.png',
        monster_a: 'gfx/monster_a.png',
        monster_b: 'gfx/monster_b.png',
        monster_who: 'gfx/monster_who.png',
        shield: 'gfx/shield.png',
        sword: 'gfx/sword.png',
        message: 'gfx/dialog.png'
      }, this.create);
    }

    Game.prototype.create = function() {
      this.monsters = [
        new Monster({
          name: 'A',
          description: 'Attaque 1000 et defense 500',
          attack: 1000,
          defense: 500,
          width: 16,
          height: 20,
          img: Assets.get('monster_a')
        }), new Monster({
          name: 'B',
          description: 'Attaque 2000 et defense nulle',
          attack: 2000,
          defense: 0,
          width: 16,
          height: 19,
          img: Assets.get('monster_b')
        })
      ];
      this.j1 = new Player();
      this.j1.add_card(new Card({
        x: 0,
        y: 0,
        monster: this.monsters[0],
        position: 'defense'
      }));
      this.j1.add_card(new Card({
        x: 50,
        y: 0,
        monster: this.monsters[1],
        position: 'attack'
      }));
      this.description = null;
      return this.update();
    };

    Game.prototype.update = function() {
      var card, _i, _len, _ref;
      this.description = null;
      document.body.style.cursor = 'default';
      _ref = this.j1.cards_ground;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        card.update_hover(this.mouse);
      }
      if (this.mouse.press()) {
        this.j1.add_card(new Card({
          x: this.j1.cards_ground.length * 50,
          y: 0,
          monster: this.monsters[1],
          position: ['attack', 'defense'][Math.rand(0, 1)],
          visible: [true, false][Math.rand(0, 1)],
          enemy: [true, false][Math.rand(0, 1)]
        }));
      }
      this.draw();
      this.mouse.update();
      return requestAnimationFrame(this.update);
    };

    Game.prototype.draw = function() {
      var card, _i, _len, _ref;
      this.ctx.fillStyle = rgb(255, 255, 255);
      this.ctx.fillRect(0, 0, this.can.width, this.can.height);
      this.ctx.drawImage(Assets.get('ground'), 0, 0);
      _ref = this.j1.cards_ground;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        card = _ref[_i];
        card.draw(this.ctx);
      }
      if (this.description != null) {
        this.window_message(this.width - 100, this.height - 50, 100, 50, this.description);
      }
    };

    Game.prototype.window_message = function(x, y, w, h, text) {
      var img_dialog;
      this.ctx.save();
      this.ctx.translate(x, y);
      img_dialog = Assets.get('message');
      this.ctx.drawImage(img_dialog, 0, 0, 8, 8, 0, 0, 8, 8);
      this.ctx.drawImage(img_dialog, 8, 0, 8, 8, 8, 0, w - 16, 8);
      this.ctx.drawImage(img_dialog, 16, 0, 8, 8, w - 8, 0, 8, 8);
      this.ctx.drawImage(img_dialog, 0, 8, 8, 8, 0, 8, 8, h);
      this.ctx.drawImage(img_dialog, 8, 8, 8, 8, 8, 8, w - 16, h);
      this.ctx.drawImage(img_dialog, 16, 8, 8, 8, w - 8, 8, 8, h);
      this.ctx.drawImage(img_dialog, 0, 16, 8, 8, 0, h + 8, 8, 8);
      this.ctx.drawImage(img_dialog, 8, 16, 8, 8, 8, h + 8, w - 16, 8);
      this.ctx.drawImage(img_dialog, 16, 16, 8, 8, w - 8, h + 8, 8, 8);
      if (text != null) {
        this.ctx.font = 'normal 8px Cardfont';
        this.ctx.fillStyle = rgb(0, 0, 0);
        this.ctx.textAlign = 'left';
        this.ctx.fill_wrap_text(text, 8, 18, w - 8, 12);
      }
      return this.ctx.restore();
    };

    return Game;

  })();

  new Game();

}).call(this);
