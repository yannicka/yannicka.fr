// Generated by CoffeeScript 1.7.1
var Game, Keyboard, Mouse, Stopwatch, bounding_box_collision, game, keycode,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

CanvasRenderingContext2D.prototype.draw_image_index = function(img, width, height, index, x, y, draw) {
  var basex, basey, nbtiles;
  if (draw == null) {
    draw = true;
  }
  nbtiles = Math.ceil(img.width / width);
  basex = index % nbtiles;
  basex = basex * width;
  basey = Math.floor(index / nbtiles);
  basey = basey * height;
  if (draw) {
    return this.drawImage(img, basex, basey, width, height, x, y, width, height);
  } else {
    return {
      nbtiles: nbtiles,
      basex: basex,
      basey: basey
    };
  }
};

CanvasRenderingContext2D.prototype.get2darray_image = function(img) {
  var a, b, g, i, list_pixels, map, r, x, y, _i, _ref;
  this.save();
  this.drawImage(img, 0, 0);
  list_pixels = this.getImageData(0, 0, img.width, img.height).data;
  map = [];
  for (i = _i = 0, _ref = list_pixels.length; _i < _ref; i = _i += 4) {
    r = list_pixels[i + 0];
    g = list_pixels[i + 1];
    b = list_pixels[i + 2];
    a = list_pixels[i + 3];
    x = Math.floor((i / 4) % img.width);
    y = Math.floor(((i - x) / 4) / img.width);
    if (map[x]) {
      map[x][y] = [r, g, b, a];
    } else {
      map[x] = [[r, g, b, a]];
    }
  }
  this.restore();
  return map;
};

CanvasRenderingContext2D.prototype.fill_wrap_text = function(text, x, y, maxWidth, lineHeight) {
  var line, metrics, n, testLine, testWidth, words, _i, _ref;
  words = text.split(' ');
  line = '';
  for (n = _i = 0, _ref = words.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
    testLine = line + words[n] + ' ';
    metrics = this.measureText(testLine);
    testWidth = metrics.width;
    if (testWidth > maxWidth) {
      this.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  return this.fillText(line, x, y);
};

CanvasRenderingContext2D.prototype.tile_from_position = function(img, width, height, x, y) {
  var tile_by_line;
  tile_by_line = Math.ceil(img.width / (width + 1));
  x = Math.floor(x / (width + 1));
  y = Math.floor(y / (height + 1));
  return x + (y * tile_by_line);
};

Math.clamp = function(min, val, max) {
  return Math.max(min, Math.min(max, val));
};

Math.sign = function(x) {
  var _ref, _ref1;
  return (_ref = x === 0) != null ? _ref : {
    0: (_ref1 = x > 0) != null ? _ref1 : {
      1: -1
    }
  };
};

Math.between = function(min, val, max) {
  return val >= min && val <= max;
};

Math.rand = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

window.rgb = function(r, g, b, a) {
  if (a == null) {
    a = 1;
  }
  if (a === 1) {
    return "rgb(" + r + ", " + g + ", " + b + ")";
  } else {
    return "rgb(" + r + ", " + g + ", " + b + ", " + a + ")";
  }
};

window.hsl = function(h, s, l, a) {
  if (a == null) {
    a = 1;
  }
  if (a === 1) {
    return "rgb(" + h + ", " + s + "%, " + l + "%)";
  } else {
    return "rgb(" + h + ", " + s + "%, " + l + "%, " + a + ")";
  }
};

window.preload_images = function(images, callback) {
  var i, image_loaded, nb_images_loaded, nb_images_to_load, new_image_loaded, preload;
  nb_images_loaded = 0;
  nb_images_to_load = Object.keys(images).length;
  image_loaded = [];
  new_image_loaded = function() {
    nb_images_loaded++;
  };
  for (i in images) {
    image_loaded[i] = new Image();
    image_loaded[i].onload = new_image_loaded;
    image_loaded[i].src = images[i];
  }
  preload = function() {
    if (nb_images_loaded === nb_images_to_load) {
      callback();
    } else {
      setTimeout(preload, 100);
    }
  };
  preload();
  return image_loaded;
};

Stopwatch = (function() {
  function Stopwatch() {
    this.dt = 0;
    this.last = Date.now();
    this.time = 0;
  }

  Stopwatch.prototype.update = function() {
    this.dt = Date.now() - this.last;
    this.last = Date.now();
    return this.time += this.dt;
  };

  return Stopwatch;

})();

Mouse = (function() {
  function Mouse(el) {
    this.onmousemove = __bind(this.onmousemove, this);
    this.onmousedown = __bind(this.onmousedown, this);
    this.onmouseup = __bind(this.onmouseup, this);
    this.x = 0;
    this.y = 0;
    this.click = null;
    this.mtime = 0;
    this.el = el;
    this.loose = null;
    document.addEventListener('mousedown', this.onmousedown, false);
    document.addEventListener('mousemove', this.onmousemove, false);
    document.addEventListener('mouseup', this.onmouseup, false);
  }

  Mouse.prototype.update = function() {
    return this.mtime++;
  };

  Mouse.prototype.onmouseup = function(e) {
    this.loose = this.mtime;
    return this.click = null;
  };

  Mouse.prototype.onmousedown = function(e) {
    this.onmousemove(e);
    return this.click = this.mtime;
  };

  Mouse.prototype.onmousemove = function(e) {
    this.x = e.pageX - (this.el != null ? this.el.offsetLeft : 0);
    return this.y = e.pageY - (this.el != null ? this.el.offsetTop : 0);
  };

  Mouse.prototype.up = function() {
    return this.click === null;
  };

  Mouse.prototype.down = function() {
    return this.click !== null;
  };

  Mouse.prototype.press = function() {
    return this.click === this.mtime;
  };

  Mouse.prototype.release = function() {
    return this.loose === this.mtime;
  };

  return Mouse;

})();

keycode = {
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  NUM0: 48,
  NUM1: 49,
  NUM2: 50,
  NUM3: 51,
  NUM4: 52,
  NUM5: 53,
  NUM6: 54,
  NUM7: 55,
  NUM8: 56,
  NUM9: 57,
  NUMPAD0: 96,
  NUMPAD1: 97,
  NUMPAD2: 98,
  NUMPAD3: 99,
  NUMPAD4: 100,
  NUMPAD5: 101,
  NUMPAD6: 102,
  NUMPAD7: 103,
  NUMPAD8: 104,
  NUMPAD9: 105,
  ADD: 107,
  SUB: 109,
  MUL: 106,
  DIV: 111,
  CAPSLOCK: 20,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  ISERT: 45,
  DELETE: 46,
  NUMLOCK: 144
};

Keyboard = (function() {
  function Keyboard() {
    this.onkeydown = __bind(this.onkeydown, this);
    this.onkeyup = __bind(this.onkeyup, this);
    this.keys = [];
    this.loose = [];
    this.last = 0;
    this.ktime = 0;
    document.addEventListener('keydown', this.onkeydown, false);
    document.addEventListener('keyup', this.onkeyup, false);
  }

  Keyboard.prototype.update = function() {
    this.ktime++;
  };

  Keyboard.prototype.onkeyup = function(e) {
    this.loose[e.keyCode] = this.ktime;
    this.keys[e.keyCode] = null;
  };

  Keyboard.prototype.onkeydown = function(e) {
    this.keys[e.keyCode] = this.ktime;
  };

  Keyboard.prototype.up = function(k) {
    return this.keys[this.str_to_code(k)] == null;
  };

  Keyboard.prototype.down = function(k) {
    return this.keys[this.str_to_code(k)] != null;
  };

  Keyboard.prototype.press = function(k) {
    return this.keys[this.str_to_code(k)] === this.ktime;
  };

  Keyboard.prototype.release = function(k) {
    return this.loose[this.str_to_code(k)] === this.ktime;
  };

  Keyboard.prototype.str_to_code = function(k) {
    k = k.toUpperCase();
    if (keycode[k]) {
      return keycode[k];
    } else {
      return null;
    }
  };

  return Keyboard;

})();

bounding_box_collision = function(b1, b2) {
  return !((b1.x > b2.x + b2.width - 1) || (b1.y > b2.y + b2.height - 1) || (b2.x > b1.x + b1.width - 1) || (b2.y > b1.y + b1.height - 1));
};

Game = (function() {
  function Game() {
    this.draw = __bind(this.draw, this);
    this.update = __bind(this.update, this);
    this.create = __bind(this.create, this);
    this.can = document.getElementById('test');
    this.ctx = this.can.getContext('2d');
    this.can.width = 640;
    this.can.height = 480;
    this.kb = new Keyboard();
    this.player = {
      x: 70,
      y: 70,
      width: 80,
      height: 40,
      dirx: 'left',
      diry: 'up'
    };
    this.enemy = {
      x: 20,
      y: 20,
      width: 42,
      height: 60
    };
    this.create();
  }

  Game.prototype.create = function() {
    return this.update();
  };

  Game.prototype.update = function() {
    var dx, dy, speed;
    this.draw();
    dx = 0;
    dy = 0;
    speed = 5;
    if (this.kb.down('left')) {
      dx -= speed;
      this.player.dirx = 'left';
    }
    if (this.kb.down('right')) {
      dx += speed;
      this.player.dirx = 'right';
    }
    if (this.kb.down('up')) {
      dy -= speed;
      this.player.diry = 'up';
    }
    if (this.kb.down('down')) {
      dy += speed;
      this.player.diry = 'down';
    }
    this.player.dirx = dx < 0 ? 'left' : dx > 0 ? 'right' : null;
    this.player.diry = dy < 0 ? 'up' : dy > 0 ? 'down' : null;
    this.player.x += dx;
    this.player.y += dy;
    if (bounding_box_collision(this.player, this.enemy)) {
      if (this.player.y + this.player.height > this.enemy.y + this.enemy.height) {
        this.player.y = this.enemy.y + this.enemy.height;
      }
      if (this.player.y < this.enemy.y) {
        this.player.y = this.enemy.y - this.player.height;
      }
    }
    if (bounding_box_collision(this.player, this.enemy)) {
      if (this.player.x + this.player.width > this.enemy.x + this.enemy.width) {
        this.player.x = this.enemy.x + this.enemy.width;
      }
      if (this.player.x < this.enemy.x) {
        this.player.x = this.enemy.x - this.player.width;
      }
    }

    /*
    		if bounding_box_collision(@player, @enemy)
    			if @player.dirx == 'left'
    				@player.x = @enemy.x + @enemy.width # droite
    
    			if @player.dirx == 'right'
    				@player.x = @enemy.x - @player.width # gauche
     */
    this.kb.update();
    return requestAnimationFrame(this.update);
  };

  Game.prototype.draw = function() {
    this.ctx.clearRect(0, 0, this.can.width, this.can.height);
    this.ctx.fillStyle = rgb(128, 0, 0);
    this.ctx.fillRect(this.enemy.x, this.enemy.y, this.enemy.width, this.enemy.height);
    this.ctx.fillStyle = rgb(0, 0, 128);
    this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
  };

  return Game;

})();

game = new Game();
