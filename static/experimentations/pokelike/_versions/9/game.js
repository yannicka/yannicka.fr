// Generated by CoffeeScript 1.7.1
var Animation, Entity, Game, Keyboard, Mouse, Player, Sprite, Stopwatch, Tile, TileAnimated, game, keycode,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CanvasRenderingContext2D.prototype.draw_image_index = function(img, width, height, index, x, y, draw) {
  var basex, basey, nbtiles;
  if (draw == null) {
    draw = true;
  }
  nbtiles = Math.ceil(img.width / width);
  basex = index % nbtiles;
  basex = basex * width;
  basey = Math.floor(index / nbtiles);
  basey = basey * height;
  if (draw) {
    return this.drawImage(img, basex, basey, width, height, x, y, width, height);
  } else {
    return {
      nbtiles: nbtiles,
      basex: basex,
      basey: basey
    };
  }
};

CanvasRenderingContext2D.prototype.get2darray_image = function(img) {
  var a, b, g, i, list_pixels, map, r, x, y, _i, _ref;
  this.save();
  this.drawImage(img, 0, 0);
  list_pixels = this.getImageData(0, 0, img.width, img.height).data;
  map = [];
  for (i = _i = 0, _ref = list_pixels.length; _i < _ref; i = _i += 4) {
    r = list_pixels[i + 0];
    g = list_pixels[i + 1];
    b = list_pixels[i + 2];
    a = list_pixels[i + 3];
    x = Math.floor((i / 4) % img.width);
    y = Math.floor(((i - x) / 4) / img.width);
    if (map[x]) {
      map[x][y] = [r, g, b, a];
    } else {
      map[x] = [[r, g, b, a]];
    }
  }
  this.restore();
  return map;
};

CanvasRenderingContext2D.prototype.fill_wrap_text = function(text, x, y, maxWidth, lineHeight) {
  var line, metrics, n, testLine, testWidth, words, _i, _ref;
  words = text.split(' ');
  line = '';
  for (n = _i = 0, _ref = words.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
    testLine = line + words[n] + ' ';
    metrics = this.measureText(testLine);
    testWidth = metrics.width;
    if (testWidth > maxWidth) {
      this.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  return this.fillText(line, x, y);
};

CanvasRenderingContext2D.prototype.tile_from_position = function(img, width, height, x, y) {
  var tile_by_line;
  tile_by_line = Math.ceil(img.width / (width + 1));
  x = Math.floor(x / (width + 1));
  y = Math.floor(y / (height + 1));
  return x + (y * tile_by_line);
};

Math.clamp = function(min, val, max) {
  return Math.max(min, Math.min(max, val));
};

Math.sign = function(x) {
  var _ref, _ref1;
  return (_ref = x === 0) != null ? _ref : {
    0: (_ref1 = x > 0) != null ? _ref1 : {
      1: -1
    }
  };
};

Math.between = function(min, val, max) {
  return val >= min && val <= max;
};

Math.rand = function(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

window.rgb = function(r, g, b, a) {
  if (a == null) {
    a = 1;
  }
  if (a === 1) {
    return "rgb(" + r + ", " + g + ", " + b + ")";
  } else {
    return "rgb(" + r + ", " + g + ", " + b + ", " + a + ")";
  }
};

window.hsl = function(h, s, l, a) {
  if (a == null) {
    a = 1;
  }
  if (a === 1) {
    return "rgb(" + h + ", " + s + "%, " + l + "%)";
  } else {
    return "rgb(" + h + ", " + s + "%, " + l + "%, " + a + ")";
  }
};

window.preload_images = function(images, callback) {
  var i, image_loaded, nb_images_loaded, nb_images_to_load, new_image_loaded, preload;
  nb_images_loaded = 0;
  nb_images_to_load = Object.keys(images).length;
  image_loaded = [];
  new_image_loaded = function() {
    nb_images_loaded++;
  };
  for (i in images) {
    image_loaded[i] = new Image();
    image_loaded[i].onload = new_image_loaded;
    image_loaded[i].src = images[i];
  }
  preload = function() {
    if (nb_images_loaded === nb_images_to_load) {
      callback();
    } else {
      setTimeout(preload, 100);
    }
  };
  preload();
  return image_loaded;
};

Stopwatch = (function() {
  function Stopwatch() {
    this.dt = 0;
    this.last = Date.now();
    this.time = 0;
  }

  Stopwatch.prototype.update = function() {
    this.dt = Date.now() - this.last;
    this.last = Date.now();
    return this.time += this.dt;
  };

  return Stopwatch;

})();

Mouse = (function() {
  function Mouse(el) {
    this.onmousemove = __bind(this.onmousemove, this);
    this.onmousedown = __bind(this.onmousedown, this);
    this.onmouseup = __bind(this.onmouseup, this);
    this.x = 0;
    this.y = 0;
    this.click = null;
    this.mtime = 0;
    this.el = el;
    this.loose = null;
    document.addEventListener('mousedown', this.onmousedown, false);
    document.addEventListener('mousemove', this.onmousemove, false);
    document.addEventListener('mouseup', this.onmouseup, false);
  }

  Mouse.prototype.update = function() {
    return this.mtime++;
  };

  Mouse.prototype.onmouseup = function(e) {
    this.loose = this.mtime;
    return this.click = null;
  };

  Mouse.prototype.onmousedown = function(e) {
    this.onmousemove(e);
    return this.click = this.mtime;
  };

  Mouse.prototype.onmousemove = function(e) {
    this.x = e.pageX - (this.el != null ? this.el.offsetLeft : 0);
    return this.y = e.pageY - (this.el != null ? this.el.offsetTop : 0);
  };

  Mouse.prototype.up = function() {
    return this.click === null;
  };

  Mouse.prototype.down = function() {
    return this.click !== null;
  };

  Mouse.prototype.press = function() {
    return this.click === this.mtime;
  };

  Mouse.prototype.release = function() {
    return this.loose === this.mtime;
  };

  return Mouse;

})();

keycode = {
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  NUM0: 48,
  NUM1: 49,
  NUM2: 50,
  NUM3: 51,
  NUM4: 52,
  NUM5: 53,
  NUM6: 54,
  NUM7: 55,
  NUM8: 56,
  NUM9: 57,
  NUMPAD0: 96,
  NUMPAD1: 97,
  NUMPAD2: 98,
  NUMPAD3: 99,
  NUMPAD4: 100,
  NUMPAD5: 101,
  NUMPAD6: 102,
  NUMPAD7: 103,
  NUMPAD8: 104,
  NUMPAD9: 105,
  ADD: 107,
  SUB: 109,
  MUL: 106,
  DIV: 111,
  CAPSLOCK: 20,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  ISERT: 45,
  DELETE: 46,
  NUMLOCK: 144
};

Keyboard = (function() {
  function Keyboard() {
    this.onkeydown = __bind(this.onkeydown, this);
    this.onkeyup = __bind(this.onkeyup, this);
    this.keys = [];
    this.loose = [];
    this.last = 0;
    this.ktime = 0;
    document.addEventListener('keydown', this.onkeydown, false);
    document.addEventListener('keyup', this.onkeyup, false);
  }

  Keyboard.prototype.update = function() {
    this.ktime++;
  };

  Keyboard.prototype.onkeyup = function(e) {
    this.loose[e.keyCode] = this.ktime;
    this.keys[e.keyCode] = null;
  };

  Keyboard.prototype.onkeydown = function(e) {
    this.keys[e.keyCode] = this.ktime;
  };

  Keyboard.prototype.up = function(k) {
    return this.keys[this.str_to_code(k)] == null;
  };

  Keyboard.prototype.down = function(k) {
    return this.keys[this.str_to_code(k)] != null;
  };

  Keyboard.prototype.press = function(k) {
    return this.keys[this.str_to_code(k)] === this.ktime;
  };

  Keyboard.prototype.release = function(k) {
    return this.loose[this.str_to_code(k)] === this.ktime;
  };

  Keyboard.prototype.str_to_code = function(k) {
    k = k.toUpperCase();
    if (keycode[k]) {
      return keycode[k];
    } else {
      return null;
    }
  };

  return Keyboard;

})();

Animation = (function() {
  function Animation(index, length, framerate, looped) {
    if (framerate == null) {
      framerate = 100;
    }
    if (looped == null) {
      looped = true;
    }
    this.start_index = index;
    this.length = length;
    this.framerate = framerate;
    this.looped = looped;
    this.index = index;
    this.time_anim = 0;
  }

  Animation.prototype.update = function(dt) {
    this.time_anim += dt;
    if (this.time_anim > this.framerate) {
      this.time_anim = 0;
      this.index++;
      if (this.index >= this.start_index + this.length) {
        return this.index = this.looped ? this.start_index : this.start_index + this.length;
      }
    }
  };

  return Animation;

})();

Sprite = (function() {
  function Sprite(name) {
    this.name = name;
    this.animations = {};
    this.cur_animation = null;
  }

  Sprite.prototype.add_animation = function(name, index, length, framerate, looped) {
    if (framerate == null) {
      framerate = 100;
    }
    if (looped == null) {
      looped = true;
    }
    return this.animations[name] = new Animation(index, length, framerate, looped);
  };

  Sprite.prototype.play = function(name) {
    if (this.animations[name] != null) {
      return this.cur_animation = this.animations[name];
    }
  };

  Sprite.prototype.update = function(dt) {
    if (this.cur_animation.length > 1) {
      return this.cur_animation.update(dt);
    }
  };

  return Sprite;

})();

Entity = (function() {
  function Entity(x, y) {
    this.sprite = new Sprite();
    this.x = x;
    this.y = y;
  }

  Entity.prototype.add_animation = function(name, index, length, framerate, looped) {
    if (framerate == null) {
      framerate = 100;
    }
    if (looped == null) {
      looped = true;
    }
    return this.sprite.add_animation(name, index, length, framerate, looped);
  };

  Entity.prototype.play = function(name) {
    return this.sprite.play(name);
  };

  Entity.prototype.update = function(dt) {
    return this.sprite.update(dt);
  };

  Entity.prototype.draw = function(ctx) {
    return ctx.draw_image_index(this.img_player, 14, 16, this.sprite.cur_animation.index, this.x, this.y);
  };

  return Entity;

})();

Tile = (function() {
  function Tile(x, y, index, high, solid) {
    this.x = x;
    this.y = y;
    this.index = index;
    this.high = high;
    this.solid = solid;
  }

  Tile.prototype.draw = function(ctx, img_tileset) {
    return ctx.draw_image_index(img_tileset, 16, 16, this.index, this.x * 16, this.y * 16);
  };

  return Tile;

})();

TileAnimated = (function(_super) {
  __extends(TileAnimated, _super);

  function TileAnimated(x, y, index, high, solid, length, speed) {
    if (speed == null) {
      speed = 200;
    }
    TileAnimated.__super__.constructor.call(this, x, y, index, high, solid);
    this.animation = new Animation(this.index, length, speed);
  }

  TileAnimated.prototype.update = function(dt) {
    this.animation.update(dt);
    return this.index = this.animation.index;
  };

  return TileAnimated;

})(Tile);

Player = (function(_super) {
  __extends(Player, _super);

  function Player(img) {
    Player.__super__.constructor.call(this, 0, 0);
    this.img_player = img;
    this.add_animation('walk_left', 1, 2);
    this.add_animation('walk_up', 4, 2);
    this.add_animation('walk_right', 7, 2);
    this.add_animation('walk_down', 10, 2);
    this.add_animation('wait_left', 0, 1);
    this.add_animation('wait_up', 3, 1);
    this.add_animation('wait_right', 6, 1);
    this.add_animation('wait_down', 9, 1);
    this.play('walk_down');
    this.dir = 'down';
    this.width = 14;
    this.height = 18;
  }

  Player.prototype.draw = function(ctx) {
    return ctx.draw_image_index(this.img_player, 14, 18, this.sprite.cur_animation.index, this.x, this.y - 2);
  };

  return Player;

})(Entity);

Game = (function() {
  function Game() {
    this.draw = __bind(this.draw, this);
    this.update = __bind(this.update, this);
    this.create = __bind(this.create, this);
    var anims, high, layer, solid, t, tile, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
    this.can = document.getElementById('game');
    this.ctx = this.can.getContext('2d');
    this.can.width = 640;
    this.can.height = 480;
    this.map = [[[0, 1, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], [[-1, -1, 2, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, 3, -1], [-1, -1, -1, -1, -1, -1, -1, 7, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, 3, -1], [-1, -1, -1, -1, -1, -1, -1, 7, -1], [-1, -1, -1, -1, -1, -1, -1, -1, -1]]];
    this.collisions = [[0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];
    anims = {
      4: 3
    };
    high = [3];
    solid = [2, 4, 7];
    this.tiles = [];
    this.tiles_animated = [];
    _ref = this.map;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      for (y = _j = 0, _ref1 = layer.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        for (x = _k = 0, _ref2 = layer.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
          t = layer[y][x];
          if (t !== -1) {
            if (anims[t]) {
              this.tiles.push(new TileAnimated(x, y, t, __indexOf.call(high, t) >= 0, __indexOf.call(solid, t) >= 0, anims[t]));
            } else {
              this.tiles.push(new Tile(x, y, t, __indexOf.call(high, t) >= 0, __indexOf.call(solid, t) >= 0));
            }
          }
        }
      }
    }
    this.tiles_animated = (function() {
      var _l, _len1, _ref3, _results;
      _ref3 = this.tiles;
      _results = [];
      for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
        tile = _ref3[_l];
        if (tile instanceof TileAnimated) {
          _results.push(tile);
        }
      }
      return _results;
    }).call(this);
    this.tiles_down = (function() {
      var _l, _len1, _ref3, _results;
      _ref3 = this.tiles;
      _results = [];
      for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
        tile = _ref3[_l];
        if (tile.high === false) {
          _results.push(tile);
        }
      }
      return _results;
    }).call(this);
    this.tiles_high = (function() {
      var _l, _len1, _ref3, _results;
      _ref3 = this.tiles;
      _results = [];
      for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
        tile = _ref3[_l];
        if (tile.high === true) {
          _results.push(tile);
        }
      }
      return _results;
    }).call(this);
    this.mouse = new Mouse(this.can);
    this.kb = new Keyboard();
    this.scale = 3;
    this.timer = new Stopwatch();
    this.expand = function() {};
    this.img = preload_images({
      player: 'game/gfx/player.png',
      tileset: 'game/gfx/tileset.png'
    }, this.create);
  }

  Game.prototype.create = function() {
    this.player = new Player(this.img.player);
    if (this.ctx.mozImageSmoothingEnabled) {
      this.ctx.mozImageSmoothingEnabled = false;
    } else if (this.ctx.webkitImageSmoothingEnabled) {
      this.ctx.webkitImageSmoothingEnabled = false;
    } else if (this.ctx.oImageSmoothingEnabled) {
      this.ctx.oImageSmoothingEnabled = false;
    }
    if (this.ctx.imageSmoothingEnabled) {
      this.ctx.imageSmoothingEnabled = false;
    }
    this.ctx.scale(this.scale, this.scale);
    return this.update();
  };

  Game.prototype.update = function() {

    /*
    		gamepads = null
    
    		if navigator.webkitGetGamepads?
    			gamepads = navigator.webkitGetGamepads()
    
    		if navigator.getGamepads?
    			gamepads = navigator.getGamepads()
    
    		if gamepads?
    			for i in [ 0 ... gamepads.length ]
    				pad = gamepads[i]
    
    				@player.x += pad.axes[0]
    				@player.y += pad.axes[1]
     */
    var dir, new_pos, the_x, the_y, tile, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.draw();
    _ref = this.tiles_animated;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      tile.update(this.timer.dt);
    }
    this.player.update(this.timer.dt);
    dir = {
      x: 'right',
      y: 'down'
    };
    new_pos = {
      x: this.player.x,
      y: this.player.y
    };
    if (this.kb.down('up')) {
      new_pos.y -= 1;
      this.player.dir = dir.y = 'up';
    }
    if (this.kb.down('down')) {
      new_pos.y += 1;
      this.player.dir = dir.y = 'down';
    }
    if (this.kb.down('right')) {
      new_pos.x += 1;
      this.player.dir = dir.x = 'right';
    }
    if (this.kb.down('left')) {
      new_pos.x -= 1;
      this.player.dir = dir.x = 'left';
    }
    _ref1 = this.tiles;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      tile = _ref1[_j];
      for (y = _k = _ref2 = Math.floor(this.player.y / 16), _ref3 = Math.floor((this.player.y + this.player.height) / 16); _ref2 <= _ref3 ? _k <= _ref3 : _k >= _ref3; y = _ref2 <= _ref3 ? ++_k : --_k) {
        the_x = dir.x === 'left' ? Math.floor(new_pos.x / 16) : Math.ceil(new_pos.x / 16);
        if (tile.solid && tile.x === the_x && tile.y === y) {
          new_pos.x = Math.round(this.player.x / 16) * 16 - (dir.x === 'right' ? -2 : 0);
        }
      }
      for (x = _l = _ref4 = Math.floor(this.player.x / 16), _ref5 = Math.floor((this.player.x + this.player.width) / 16); _ref4 <= _ref5 ? _l <= _ref5 : _l >= _ref5; x = _ref4 <= _ref5 ? ++_l : --_l) {
        the_y = dir.y === 'up' ? Math.floor(new_pos.y / 16) : Math.ceil(new_pos.y / 16);
        if (tile.solid && tile.x === x && tile.y === the_y) {
          new_pos.y = Math.round(this.player.y / 16) * 16 - (dir.y === 'down' ? 2 : 0);
        }
      }
    }
    this.expand = function() {
      var _m, _n, _ref6, _ref7, _ref8, _ref9, _results;
      this.ctx.lineWidth = 2;
      this.ctx.strokeStyle = rgb(255, 0, 0);
      for (y = _m = _ref6 = Math.floor(this.player.y / 16), _ref7 = Math.floor((this.player.y + this.player.height) / 16); _ref6 <= _ref7 ? _m <= _ref7 : _m >= _ref7; y = _ref6 <= _ref7 ? ++_m : --_m) {
        the_x = dir.x === 'left' ? Math.floor(new_pos.x / 16) : Math.ceil(new_pos.x / 16);
        this.ctx.strokeRect(the_x * 16, y * 16, 16, 16);
      }
      this.ctx.lineWidth = 1;
      this.ctx.strokeStyle = rgb(0, 0, 255);
      _results = [];
      for (x = _n = _ref8 = Math.floor(this.player.x / 16), _ref9 = Math.floor((this.player.x + this.player.width) / 16); _ref8 <= _ref9 ? _n <= _ref9 : _n >= _ref9; x = _ref8 <= _ref9 ? ++_n : --_n) {
        the_y = dir.y === 'up' ? Math.floor(new_pos.y / 16) : Math.ceil(new_pos.y / 16);
        _results.push(this.ctx.strokeRect(x * 16, the_y * 16, 16, 16));
      }
      return _results;
    };
    if (this.player.x === new_pos.x && this.player.y === new_pos.y) {
      this.player.play("wait_" + this.player.dir);
    } else {
      this.player.play("walk_" + this.player.dir);
    }
    this.player.x = new_pos.x;
    this.player.y = new_pos.y;
    this.mouse.update();
    this.kb.update();
    this.timer.update();
    return requestAnimationFrame(this.update);
  };

  Game.prototype.draw = function() {
    var tile, _i, _j, _len, _len1, _ref, _ref1;
    this.ctx.clearRect(0, 0, this.can.width, this.can.height);
    _ref = this.tiles_down;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      tile.draw(this.ctx, this.img.tileset);
    }
    this.player.draw(this.ctx);
    _ref1 = this.tiles_high;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      tile = _ref1[_j];
      tile.draw(this.ctx, this.img.tileset);
    }
    this.expand();
  };

  return Game;

})();

game = new Game();
